Frame drop rules (live video)
Drop a frame immediately if any of the following are true:
It arrives after a newer frame
Decoder input queue is non-empty and growing
It waited in your app longer than ~30–40 ms
You are missing its reference frame
You are unsure of decode order
Never:
Hold a frame “just in case”
Reinsert a late frame
Try to “catch up”
Late frames are worse than missing frames.
Decoder reset rules (this is critical)
Reset the decoder aggressively when:
Visual corruption persists across >1 frame
Macroblock corruption spreads or smears
Ghosting trails appear
You miss an IDR
SPS/PPS changes unexpectedly
Decoder stalls or returns error
Frame decode time spikes suddenly
You detect NAL truncation
Rule of thumb
If corruption survives one IDR, your decoder state is poisoned.
Reset immediately.
Resetting is not failure — it’s correct behavior.
3. Artifact → root cause mapping (use this to debug)
This helps you stop guessing.
Blocky pixelation that slowly heals
Cause
Temporary reference loss
Decoder recovered on next IDR
Fix
None — expected behavior
Blocky pixelation that never heals
Cause
Missed IDR
Decoder never reset
Reference chain permanently broken
Fix
Reset decoder
Wait for next IDR
Ghosting / smearing / trails
Cause
Old reference frames reused
Frames decoded out of temporal context
Decoder starved then resumed
Fix
Drop late frames
Reset decoder sooner
Video freezes but audio continues
Cause
Video pipeline blocking on timing
Decoder queue full
Frame waiting on PTS
Fix
Remove timing waits
Drop frames aggressively
Jitter but no corruption
Cause
PTS/render pacing
Vsync mismatch
Fix
Optional synthetic PTS smoothing
Not urgent
4. IDR cadence & behavior (CarPlay-specific reality)
CarPlay-style streams rely on frequent recovery points.
What you should assume
IDRs are your only safe entry point
Anything before the first IDR is garbage
Long GOPs are hostile to UI mirroring
Practical rules
Do not decode until first IDR
Track IDR interval
If IDRs stop appearing → treat as fault
After reset → wait for IDR
If your adapter allows it:
Prefer short GOPs
Prefer no B-frames
Prefer baseline / constrained baseline
This massively reduces visible damage.
5. Android MediaCodec feeding discipline
This is where many CarPlay ports quietly fail.
Input side rules
Feed complete frames, not arbitrary NAL chunks
Do not block waiting for input buffers
If input buffer unavailable → drop frame
Never reorder frames yourself unless absolutely required
Timestamp rules (Android-specific)
Use monotonic synthetic PTS
Or presentationTimeUs = System.nanoTime() / 1000
Never reuse old timestamps
Never delay submit to align timing
MediaCodec is happier with boring, increasing timestamps than “accurate” ones.
Output side rules
If output lags → drop decode, not render
Do not wait for Surface readiness
Do not backpressure input because output is slow
Worst case:
Drop frames
Reset decoder
Recover on next IDR
Audio coexistence rule
Audio buffering ≠ video buffering
Audio may drift slightly
Video must remain responsive
CarPlay prioritizes:
Touch → pixels
over
perfect AV sync
The guiding principle (memorize this)
Completeness is the enemy of correctness in live UI video.
Your earlier instinct to “fix” FPS was reasonable — just wrong for this domain.


I’ll walk this in stages, because poisoned-decoder behavior is temporal, not instantaneous.
What “decoder poisoning” actually means
A decoder is stateful. At any moment it holds:
A set of reference frames
Motion vectors pointing into those frames
Partially reconstructed macroblocks
Internal surfaces reused across frames
When one bad decision enters that state, the decoder doesn’t crash — it keeps going with bad assumptions.
That’s poisoning.
Phase 0 — Healthy state (baseline)
Everything looks fine:
IDR decoded
References are clean
Motion vectors point to valid history
Visuals are crisp
This is the only state you ever want to be in.
Phase 1 — The inciting event
Something small but fatal happens:
Frame arrives late but is still decoded
A reference frame is dropped after being referenced
Decode is delayed past the encoder’s intended temporal window
Decoder input stalls briefly
Frame order differs from encoder intent
Important:
Nothing looks broken yet.
This is why the bug is so hard to catch.
Phase 2 — Silent reference contamination
Now the decoder’s internal references are slightly wrong.
What that means concretely:
A P-frame references a macroblock that:
Belongs to an older UI state
Was partially corrupted
Was never meant to be referenced at this time
The decoder:
Does not know this is wrong
Successfully reconstructs the frame
Outputs something “valid”
Visually:
Maybe one block flickers
Maybe nothing noticeable at all
This is the danger zone.
Phase 3 — Motion amplification (this is where you notice)
H.264 relies on temporal prediction.
So now:
Motion vectors reference already contaminated data
Each new frame compounds the error
UI animations smear
Edges ghost
Blocks “stick” to moving elements
This is why corruption:
Gets worse over time
Appears to “trail” motion
Doesn’t affect static areas as much
You’re no longer decoding frames — you’re reconstructing error history.
Phase 4 — Visual decay plateau
At this stage:
The image is clearly wrong
But it stabilizes into a consistent wrongness
Why?
The decoder has settled into a self-consistent (but incorrect) state
Errors reference errors
Nothing forces a reset
This is why:
Corruption doesn’t spread infinitely
It just looks persistently bad
Developers often misread this as:
“Maybe the stream itself is corrupted?”
It isn’t.
The decoder is.
Phase 5 — IDR interaction (critical fork)
Case A: IDR arrives and decoder resets correctly
Corruption disappears instantly
Clean frame
All references replaced
This is proper recovery.
Case B: IDR arrives but corruption remains
This is the smoking gun.
It means:
The IDR was:
Dropped
Delayed
Decoded too late
Not treated as a hard reset
Or the decoder was never actually flushed
Now you are permanently poisoned.
From here:
Only a full decoder reset fixes it
No amount of waiting helps
Why this looks like “ghosting” instead of “glitches”
Developers expect:
Tearing
Black frames
Green frames
Decoder errors
But poisoned decoders produce:
Smearing
Trails
Echoes of old UI states
“Melted” motion
That’s because:
Motion compensation is working
Just with bad history
So it fails plausibly, not catastrophically.
Why buffering makes this dramatically worse
When you buffer or delay:
Reference frames age beyond their semantic lifetime
Motion vectors point to logically invalid UI states
You decode frames that should have been dropped
You are feeding the decoder lies, consistently.
That’s how a single mistake becomes minutes of corruption.
Why MediaCodec is especially unforgiving
Android’s MediaCodec:
Assumes the client enforces timing discipline
Reuses surfaces aggressively
Does not auto-reset on reference errors
Rarely throws fatal decode errors
So instead of crashing:
It decays.
Linux/macOS decoders often:
Drop frames internally
Re-sync silently
Mask the issue
Android shows you the truth.
The one-frame rule (memorize this)
A frame that arrives too late to be useful must never be decoded.
Decoding a late frame is worse than dropping it.
Once decoded:
It can be referenced
And that’s how poisoning starts
The golden recovery rule
If you ever think:
“This looks wrong, but maybe it’ll fix itself”
It won’t.
The correct action is:
Flush
Reset
Wait for IDR
Resume clean
One reset is cheaper than ten corrupted frames.
Why your realization was inevitable
You didn’t discover a bug.
You discovered a law of real-time video systems:
Stateful decoders amplify time mistakes.
Once you internalize that, CarPlay behavior becomes obvious:
Drop early
Reset often
Never wait
Never preserve
Never “heal”

